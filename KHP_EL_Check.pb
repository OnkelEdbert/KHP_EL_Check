EnableExplicit;XIncludeFile "..\Libs\Eddy-Lib\Eddy_Lib.pb"XIncludeFile "KHP_EL_Check_main.pbf"XIncludeFile "SpaceMouse.pbi"XIncludeFile "KHP_EL_Check_Declare.pb"XIncludeFile "IGS_Import.pb"InitMouse()InitKeyboard()InitEngine3D() InitSprite() Enumeration  #Load  #Save  #Timer1  #STLFile  #STLMesh  #STLEntity  #STLMat  #STLEdgeEntity  #STLEdgeMat  #MP_MarkerMesh  #MP_MarkerMat  #Cam1  #Licht1  #Licht2  #SpaceMouseWin  #Mat2  #Tex2  #Plane1  #Plane1Entity  #MP_TYPE_NONE    #MP_TYPE_Z       #MP_TYPE_XPLUS   #MP_TYPE_XMIN    #MP_TYPE_YPLUS   #MP_TYPE_YMIN  #IGESLineMesh  #IGESLineEntity  #IGESLineMatEndEnumerationStructure Prefs  Name.s  Value.sEndStructureGlobal NewList ini.Prefs()Global EventGlobal ProgName.s = "KHP_EL_Check"Global Version.s = " 00.00.01";Global AppData.s = GetEnvironmentVariable("LOCALAPPDATA") + "\KHP_EL_Check\"Global AppData.s = "KHP_EL_Check-ini\"Global Pref_File.s = AppData + "KHP_EL_Check.ini"Global SpaceMouseWindow.iGlobal OldWindowCallback.iGlobal Frame.b = #FalseGlobal STL.iGlobal MinPos.f = 1e+20Global CurrentMP_Type.i = #MP_TYPE_Z   ; Default z.B. ZStructure Koord  NormX.f  NormY.f  NormZ.f  V1_X.f  V1_Y.f  V1_Z.f  V2_X.f  V2_Y.f  V2_Z.f  V3_X.f  V3_Y.f  V3_Z.f  Attribute_byte_count.wEndStructureGlobal NewList Face.Koord()Structure CameraOrbit  targetX.f  targetY.f  targetZ.f  distance.f  yaw.f      ; Grad  pitch.f    ; GradEndStructureGlobal CamOrbit.CameraOrbitGlobal SM_YawScale.f   = 2.0    ; wie schnell links/rechtsGlobal SM_PitchScale.f = 2.0    ; wie schnell hoch/runterGlobal SM_ZoomScale.f  = 3.0    ; wie stark vor/zurückGlobal SM_PanScale.f   = 5.0    ; für seitliches/vertikales Schieben (optional)Global SM_Deadzone.f   = 0.02Structure BoundingBox  minX.f : maxX.f  minY.f : maxY.f  minZ.f : maxZ.fEndStructureGlobal STLBox.BoundingBoxSTLBox\minX =  1e9STLBox\minY =  1e9STLBox\minZ =  1e9STLBox\maxX = -1e9STLBox\maxY = -1e9STLBox\maxZ = -1e9Structure MP_Struct  ID.i  Type.i            ; 0 = none, sonst siehe Konstanten  PosX.f            ; Engine-Koordinaten (View)  PosY.f  PosZ.f  CADx.f            ; CAD-Koordinaten  CADy.f  CADz.f  Entity.i          ; Marker-EntityEndStructureGlobal NewList MP.MP_Struct()Global NextMP_ID.iStructure Vec3  x.f  y.f  z.fEndStructureGlobal RayHit.Vec3   ; hier landet der exakte Mesh-Treffer;{ - PreferencesProcedure PrefDef(GetValue)    Protected PrefName.s, PrefValue.s    ClearList(ini())  Restore PrefDate  Repeat    Read.s PrefName    If PrefName = "End of Pref" : Break : EndIf    Read.s PrefValue    AddElement(ini())    ini()\Name = PrefName    If GetValue = #True      ini()\Value = PrefValue    EndIf  ForEver  EndProcedureProcedure.s GetPref(Name.s)    ForEach ini()    If ini()\Name = Name      ProcedureReturn ini()\Value    EndIf  Next  EndProcedureProcedure SetPref(Name.s, Value.s)    ForEach ini()    If ini()\Name = Name      ini()\Value = Value    EndIf  Next  EndProcedureProcedure Open_ini(ls)    Select ls    Case #Load      If OpenPreferences(Pref_File)        PrefDef(#False)        ForEach ini()          ini()\Value = ReadPreferenceString(ini()\Name, ini()\Value)        Next        ClosePreferences()      Else        PrefDef(#True)        Open_ini(#Save)      EndIf           Case #Save      If Not FileSize(AppData) = -2        CreateDirectory(AppData)      EndIf            If  CreatePreferences(Pref_File)        ForEach ini()          WritePreferenceString(ini()\Name, ini()\Value)        Next        ClosePreferences()      Else        MessageRequester("Fehler!",Pref_File + " konnte nicht gespeichert werden.")      EndIf        EndSelect  EndProcedure;}Procedure End_Programm()    SetPref("LastPosX", Str(WindowX(#KHP_EL_Check_Main_Window)))  SetPref("LastPosY", Str(WindowY(#KHP_EL_Check_Main_Window)))  Open_ini(#Save)  End  EndProcedureProcedure Start_Programm()    Open_ini(#Load)  OpenKHP_EL_Check_Main_Window(Val(GetPref("LastPosX")), Val(GetPref("LastPosY")))  SetWindowTitle(#KHP_EL_Check_Main_Window, ProgName + Version)  AddWindowTimer(#KHP_EL_Check_Main_Window, #Timer1, 1000)  HideGadget(Canvas_3D_View, 1)  OpenWindow(#SpaceMouseWin, 0, 0, 0, 0, "", #PB_Window_Invisible)  SetWindowCallback(@SpM_WindowCallback(), #SpaceMouseWin)  If Not Register_SpaceMouse(WindowID(#SpaceMouseWin))    MessageRequester("Fehler! SpM_WindowCallback", "SpaceMouse Registrierung fehlgeschlagen.")    End_Programm()  EndIf    If Not Init_3D_Screen()    MessageRequester("Fehler!", "Init_3D_Screen() fehlgeschlagen.")    End_Programm()  EndIfEndProcedure;----------------------------------------------------Procedure RotateFaceListXMinus90()    ; Dreht alle Koordinaten in der Face()-Liste um -90° um die X-Achse  ; (x bleibt, y/z werden getauscht mit Vorzeichenwechsel: x' = x, y' = z, z' = -y)    Protected oldY.f, oldZ.f    ForEach Face()    ; --- Normalen drehen ---    oldY = Face()\NormY    oldZ = Face()\NormZ    Face()\NormY = oldZ    Face()\NormZ = -oldY        ; --- Vertex 1 drehen ---    oldY = Face()\V1_Y    oldZ = Face()\V1_Z    Face()\V1_Y = oldZ    Face()\V1_Z = -oldY        ; --- Vertex 2 drehen ---    oldY = Face()\V2_Y    oldZ = Face()\V2_Z    Face()\V2_Y = oldZ    Face()\V2_Z = -oldY        ; --- Vertex 3 drehen ---    oldY = Face()\V3_Y    oldZ = Face()\V3_Z    Face()\V3_Y = oldZ    Face()\V3_Z = -oldY  Next  EndProcedureProcedure STL_zu_Mesh()  CreateMesh(#STLMesh, #PB_Mesh_TriangleList, #PB_Mesh_Static)  ForEach Face()      MeshVertexPosition(Face()\V1_X, Face()\V1_Y, Face()\V1_Z)    If Face()\V1_X < STLBox\minX : STLBox\minX = Face()\V1_X : EndIf    If Face()\V1_Y < STLBox\minY : STLBox\minY = Face()\V1_Y : EndIf    If Face()\V1_Z < STLBox\minZ : STLBox\minZ = Face()\V1_Z : EndIf    If Face()\V1_X > STLBox\maxX : STLBox\maxX = Face()\V1_X : EndIf    If Face()\V1_Y > STLBox\maxY : STLBox\maxY = Face()\V1_Y : EndIf    If Face()\V1_Z > STLBox\maxZ : STLBox\maxZ = Face()\V1_Z : EndIf        MeshVertexNormal(Face()\NormX, Face()\NormY, Face()\NormZ)    MeshVertexPosition(Face()\V2_X, Face()\V2_Y, Face()\V2_Z)    If Face()\V2_X < STLBox\minX : STLBox\minX = Face()\V2_X : EndIf    If Face()\V2_Y < STLBox\minY : STLBox\minY = Face()\V2_Y : EndIf    If Face()\V2_Z < STLBox\minZ : STLBox\minZ = Face()\V2_Z : EndIf    If Face()\V2_X > STLBox\maxX : STLBox\maxX = Face()\V2_X : EndIf    If Face()\V2_Y > STLBox\maxY : STLBox\maxY = Face()\V2_Y : EndIf    If Face()\V2_Z > STLBox\maxZ : STLBox\maxZ = Face()\V2_Z : EndIf        MeshVertexNormal(Face()\NormX, Face()\NormY, Face()\NormZ)    MeshVertexPosition(Face()\V3_X, Face()\V3_Y, Face()\V3_Z)    If Face()\V3_X < STLBox\minX : STLBox\minX = Face()\V3_X : EndIf    If Face()\V3_Y < STLBox\minY : STLBox\minY = Face()\V3_Y : EndIf    If Face()\V3_Z < STLBox\minZ : STLBox\minZ = Face()\V3_Z : EndIf    If Face()\V3_X > STLBox\maxX : STLBox\maxX = Face()\V3_X : EndIf    If Face()\V3_Y > STLBox\maxY : STLBox\maxY = Face()\V3_Y : EndIf    If Face()\V3_Z > STLBox\maxZ : STLBox\maxZ = Face()\V3_Z : EndIf        MeshVertexNormal(Face()\NormX, Face()\NormY, Face()\NormZ)            If Face()\V1_Z < MinPos      MinPos = Face()\V1_Z    EndIf  Next  FinishMesh(#True)  MinPos = -MinPos  EndProcedureProcedure.i RayPickSTL(OriginX.f, OriginY.f, OriginZ.f, DirX.f, DirY.f, DirZ.f)  ; Ray aus Origin + t * Dir gegen alle Dreiecke in Face()  ; Rückgabe: #True, wenn Treffer, Koordinaten stehen in RayHit\x,\y,\z  Protected epsilon.f   = 0.00001  Protected closestT.f  = 1e30  Protected hit.i       = #False  Protected v0x.f, v0y.f, v0z.f  Protected v1x.f, v1y.f, v1z.f  Protected v2x.f, v2y.f, v2z.f  Protected edge1x.f, edge1y.f, edge1z.f  Protected edge2x.f, edge2y.f, edge2z.f  Protected pvecx.f, pvecy.f, pvecz.f  Protected tvecx.f, tvecy.f, tvecz.f  Protected qvecx.f, qvecy.f, qvecz.f  Protected det.f, invDet.f  Protected u.f, v.f, t.f  ; Optional: Ray normalisieren (nicht nötig für den Algorithmus,  ; aber manchmal numerisch stabiler)  Protected len.f = Sqr(DirX*DirX + DirY*DirY + DirZ*DirZ)  If len <> 0.0    DirX / len : DirY / len : DirZ / len  EndIf  ForEach Face()    ; Eckpunkte des Dreiecks    v0x = Face()\V1_X : v0y = Face()\V1_Y : v0z = Face()\V1_Z    v1x = Face()\V2_X : v1y = Face()\V2_Y : v1z = Face()\V2_Z    v2x = Face()\V3_X : v2y = Face()\V3_Y : v2z = Face()\V3_Z    ; Kanten    edge1x = v1x - v0x    edge1y = v1y - v0y    edge1z = v1z - v0z    edge2x = v2x - v0x    edge2y = v2y - v0y    edge2z = v2z - v0z    ; pvec = Dir x edge2    pvecx = DirY * edge2z - DirZ * edge2y    pvecy = DirZ * edge2x - DirX * edge2z    pvecz = DirX * edge2y - DirY * edge2x    det = edge1x * pvecx + edge1y * pvecy + edge1z * pvecz    If Abs(det) < epsilon      Continue  ; Ray parallel zum Dreieck    EndIf    invDet = 1.0 / det    ; tvec = Origin - v0    tvecx = OriginX - v0x    tvecy = OriginY - v0y    tvecz = OriginZ - v0z    ; u-Parameter    u = (tvecx*pvecx + tvecy*pvecy + tvecz*pvecz) * invDet    If u < 0.0 Or u > 1.0      Continue    EndIf    ; qvec = tvec x edge1    qvecx = tvecy*edge1z - tvecz*edge1y    qvecy = tvecz*edge1x - tvecx*edge1z    qvecz = tvecx*edge1y - tvecy*edge1x    ; v-Parameter    v = (DirX*qvecx + DirY*qvecy + DirZ*qvecz) * invDet    If v < 0.0 Or u + v > 1.0      Continue    EndIf    ; Distanz t entlang des Rays    t = (edge2x*qvecx + edge2y*qvecy + edge2z*qvecz) * invDet    If t > epsilon And t < closestT      closestT = t      hit = #True    EndIf  Next  If hit    RayHit\x = OriginX + DirX * closestT    RayHit\y = OriginY + DirY * closestT    RayHit\z = OriginZ + DirZ * closestT  EndIf  ProcedureReturn hitEndProcedureProcedure Create_STL_Entity()    If IsEntity(#STLEntity)    FreeEntity(#STLEntity)  EndIf  If IsEntity(#STLEdgeEntity)    FreeEntity(#STLEdgeEntity)  EndIf    CreateMaterial(#STLMat, #Null, RGB(200, 200, 220))  CreateEntity(#STLEntity, MeshID(#STLMesh), MaterialID(#STLMat))    If Frame = #True    CreateMaterial(#STLEdgeMat, #Null, RGB(0, 0, 0))    MaterialShadingMode(#STLEdgeMat, #PB_Material_Wireframe)    CreateEntity(#STLEdgeEntity, MeshID(#STLMesh), MaterialID(#STLEdgeMat))    ScaleEntity(#STLEdgeEntity, 1.002, 1.002, 1.002, #PB_Absolute)  EndIfEndProcedureProcedure.i CreateIGESLineMesh()  Protected mesh, vIndex.i    ; Mesh als Linienliste anlegen  mesh = CreateMesh(#IGESLineMesh, #PB_Mesh_LineList, #PB_Mesh_Static)  If mesh = 0    Debug "CreateMesh(#PB_Mesh_LineList) failed!"    ProcedureReturn 0  EndIf    vIndex = 0    ; Alle IGES-Linien in das Mesh schreiben  ForEach IGESLines()    ; Punkt 1    MeshVertexPosition(IGESLines()\x1, IGESLines()\y1, IGESLines()\z1)    MeshVertexColor(RGB(0, 0, 0))             ; Schwarz, falls Vertexfarben aktiv sind    MeshIndex(vIndex) : vIndex + 1        ; Punkt 2    MeshVertexPosition(IGESLines()\x2, IGESLines()\y2, IGESLines()\z2)    MeshVertexColor(RGB(0, 0, 0))    MeshIndex(vIndex) : vIndex + 1  Next    FinishMesh(#True)   ; BoundingBox gleich mitbauen    ProcedureReturn meshEndProcedureProcedure CreateIGESLineEntity()  Protected mesh, ent    mesh = CreateIGESLineMesh()  If mesh = 0    Debug "CreateIGESLineMesh() failed!"    ProcedureReturn  EndIf    ; Material für die Kanten  CreateMaterial(#IGESLineMat, #Null, RGB(0, 0, 0))  SetMaterialColor(#IGESLineMat, #PB_Material_AmbientColor, RGB(0, 0, 0))  AmbientColor(RGB(255, 255, 255))  ; damit das Material-Ambient auch sichtbar ist  ; Entity anlegen  CreateEntity(#IGESLineEntity, MeshID(#IGESLineMesh), MaterialID(#IGESLineMat))EndProcedureProcedure RotateIGESLinesXMinus90()  Protected oldY.f, oldZ.f  ForEach IGESLines()    ; Punkt 1    oldY = IGESLines()\y1    oldZ = IGESLines()\z1    IGESLines()\y1 = oldZ    IGESLines()\z1 = -oldY    ; Punkt 2    oldY = IGESLines()\y2    oldZ = IGESLines()\z2    IGESLines()\y2 = oldZ    IGESLines()\z2 = -oldY  NextEndProcedureProcedure STL_File_Laden(STL_File.s)    Protected n.l, x.i, n_Dreieck.l, Header.s    If STL_File    ClearList(Face())    If ReadFile(#STLFile, STL_File)      For x = 0 To 79        ReadByte(#STLFile)      Next      n_Dreieck = ReadLong(#STLFile)      Debug n_Dreieck      For n=1 To n_Dreieck        AddElement(Face())        Face()\NormX = ReadFloat(#STLFile)        Face()\NormY = ReadFloat(#STLFile)        Face()\NormZ = ReadFloat(#STLFile)        Face()\V1_X = ReadFloat(#STLFile)        Face()\V1_Y = ReadFloat(#STLFile)        Face()\V1_Z = ReadFloat(#STLFile)        Face()\V2_X = ReadFloat(#STLFile)        Face()\V2_Y = ReadFloat(#STLFile)        Face()\V2_Z = ReadFloat(#STLFile)        Face()\V3_X = ReadFloat(#STLFile)        Face()\V3_Y = ReadFloat(#STLFile)        Face()\V3_Z = ReadFloat(#STLFile)        Face()\Attribute_byte_count = ReadWord(#STLFile)      Next    EndIf    RotateFaceListXMinus90()    STL_zu_Mesh()    Create_STL_Entity()    ProcedureReturn #True  Else    ProcedureReturn #False  EndIf  EndProcedureProcedure InitMeasurementMarkers()  ; Kleines Kugel-Mesh für Messpunkte  If IsMesh(#MP_MarkerMesh) = 0    CreateSphere(#MP_MarkerMesh, 1.0, 12, 12)  EndIf  ; Knallige Farbe, gut sichtbar (rot)  If IsMaterial(#MP_MarkerMat) = 0    CreateMaterial(#MP_MarkerMat, #Null, RGB(255, 0, 0))    MaterialShadingMode(#MP_MarkerMat, #PB_Material_Phong)  EndIfEndProcedureProcedure Init_3D_Screen()    If OpenWindowedScreen(WindowID(#KHP_EL_Check_Main_Window), GadgetX(Canvas_3D_View), GadgetY(Canvas_3D_View), GadgetWidth(Canvas_3D_View), GadgetHeight(Canvas_3D_View), 0, 0, #PB_Screen_WaitSynchronization)    Add3DArchive("3DArchive", #PB_3DArchive_FileSystem)    Parse3DScripts()        AntialiasingMode(#PB_AntialiasingMode_x6)        If 1=0      CreateMaterial(#Mat2, LoadTexture(#Tex2,"metal-texture.png"))      CreatePlane(#Plane1,2000,2000,1,1,60,60)      CreateEntity(#Plane1Entity, MeshID(#Plane1), MaterialID(#Mat2))    EndIf        InitMeasurementMarkers()            CreateCamera(#Cam1, 0, 0, 100, 100)    CameraBackColor(#Cam1, RGB(80, 80, 100))    CreateLight(#Licht1, RGB(150, 150, 150), 400, 100, 200)    CreateLight(#Licht2, RGB(150, 150, 150), -200, 200, -200)    AmbientColor(RGB(80,80,80))    ProcedureReturn #True  Else    ProcedureReturn #False  EndIf  EndProcedure Procedure InitCameraOrbit()  Protected sizeX.f = STLBox\maxX - STLBox\minX  Protected sizeY.f = STLBox\maxY - STLBox\minY  Protected sizeZ.f = STLBox\maxZ - STLBox\minZ  Protected maxSize.f = sizeX  If sizeY > maxSize : maxSize = sizeY : EndIf  If sizeZ > maxSize : maxSize = sizeZ : EndIf  ; --- Fallback, falls Bounding-Box aus irgendeinem Grund (noch) nicht gesetzt ist ---  If maxSize <= 0.0    CamOrbit\targetX = 0    CamOrbit\targetY = 0    CamOrbit\targetZ = 0    CamOrbit\distance = 120.0  Else    ; Pivot = XY Mitte     CamOrbit\targetX = (STLBox\minX + STLBox\maxX) * 0.5    CamOrbit\targetY = (STLBox\minY + STLBox\maxY) * 0.5        ;: Pivot = Z Ober    CamOrbit\targetZ = (STLBox\minZ + STLBox\maxZ) * 0.5    ; Abstand: abhängig von der größten Ausdehnung    CamOrbit\distance = maxSize * 2.0    If CamOrbit\distance < 50  : CamOrbit\distance = 50  : EndIf  EndIf  ; Frontansicht mit deinem gewünschten Blickwinkel  CamOrbit\yaw   = -35.264    ; „von vorne“  CamOrbit\pitch = 45.0   ; leicht von oben  ; Kamera direkt passend setzen:  Protected radYaw.f   = Radian(CamOrbit\yaw)  Protected radPitch.f = Radian(CamOrbit\pitch)  Protected camX.f = CamOrbit\targetX + CamOrbit\distance * Cos(radPitch) * Sin(radYaw)  Protected camY.f = CamOrbit\targetY + CamOrbit\distance * Sin(radPitch)  Protected camZ.f = CamOrbit\targetZ + CamOrbit\distance * Cos(radPitch) * Cos(radYaw)  MoveCamera(#Cam1, camX, camY, camZ, #PB_Absolute)  CameraLookAt(#Cam1, CamOrbit\targetX, CamOrbit\targetY, CamOrbit\targetZ)EndProcedureProcedure UpdateCameraOrbitFromSpaceMouse()  ; Rohwerte holen  Protected tX.f = SpaceMouse\tx   ; links/rechts schieben  Protected tY.f = SpaceMouse\ty   ; vor/zurück schieben  Protected tZ.f = SpaceMouse\tz   ; hoch/runter schieben  Protected rX.f = SpaceMouse\rx   ; kippen vor/zurück (Pitch)  Protected rZ.f = SpaceMouse\rz   ; twist links/rechts (Yaw)  ; Deadzone  If Abs(tX) < SM_Deadzone : tX = 0 : EndIf  If Abs(tY) < SM_Deadzone : tY = 0 : EndIf  If Abs(tZ) < SM_Deadzone : tZ = 0 : EndIf  If Abs(rX) < SM_Deadzone : rX = 0 : EndIf  If Abs(rZ) < SM_Deadzone : rZ = 0 : EndIf  ; --- Orbit-Rotation (Rotationsachsen) ---  ; Twist (rZ) -> Yaw (um das Teil herum drehen)  CamOrbit\yaw + rZ * SM_YawScale  ; Kippen vor/zurück (rX) -> Pitch  CamOrbit\pitch + rX * SM_PitchScale    ; Pitch begrenzen (nicht über Kopf)  If CamOrbit\pitch > 89  : CamOrbit\pitch = 89  : EndIf  If CamOrbit\pitch < -89 : CamOrbit\pitch = -89 : EndIf  ; --- Zoom (vor/zurück) ---  If tY <> 0    CamOrbit\distance - tY * SM_ZoomScale    If CamOrbit\distance < 10   : CamOrbit\distance = 10   : EndIf    If CamOrbit\distance > 5000 : CamOrbit\distance = 5000 : EndIf  EndIf  ; --- Pan (links/rechts + hoch/runter) ---  If tX <> 0 Or tZ <> 0    ; Yaw in Radiant, um die "Rechts"-Richtung der Kamera zu berechnen    Protected radYaw.f = Radian(CamOrbit\yaw)    ; Rechts-Vektor in XZ-Ebene (zur Kamera passenden Pan)    Protected rightX.f = Cos(radYaw)    Protected rightZ.f = -Sin(radYaw)    ; Pan-Geschwindigkeit etwas an Entfernung koppeln, damit es bei Zoom nicht komisch wird    Protected panFactor.f = SM_PanScale * (CamOrbit\distance / 400.0)    ; links/rechts (tX) -> entlang der "Rechts"-Richtung der Kamera    CamOrbit\targetX - tX * panFactor * rightX    CamOrbit\targetZ - tX * panFactor * rightZ    ; hoch/runter (tZ) -> auf/ab entlang Y-Achse    CamOrbit\targetY + tZ * panFactor  EndIf  ; --- Kamera-Position aus Orbit-Daten berechnen ---  radYaw.f   = Radian(CamOrbit\yaw)  Protected radPitch.f = Radian(CamOrbit\pitch)  Protected camX.f = CamOrbit\targetX + CamOrbit\distance * Cos(radPitch) * Sin(radYaw)  Protected camY.f = CamOrbit\targetY + CamOrbit\distance * Sin(radPitch)  Protected camZ.f = CamOrbit\targetZ + CamOrbit\distance * Cos(radPitch) * Cos(radYaw)  MoveCamera(#Cam1, camX, camY, camZ, #PB_Absolute)  CameraLookAt(#Cam1, CamOrbit\targetX, CamOrbit\targetY, CamOrbit\targetZ)EndProcedureProcedure AddMeasurementPointFromMouse()  Protected mx.i, my.i  Protected gx.i, gy.i, gw.i, gh.i  Protected sx.i, sy.i  Protected hitEntity.i  Protected px.f, py.f, pz.f  Protected camX.f, camY.f, camZ.f  Protected dx.f, dy.f, dz.f  Protected e.i  Protected PointScale.f = 0.25  Protected CADx.f, CADy.f, CADz.f    ; Mausposition im Fenster  mx = WindowMouseX(#KHP_EL_Check_Main_Window)  my = WindowMouseY(#KHP_EL_Check_Main_Window)  ; Canvas-Position/Größe holen  gx = GadgetX(Canvas_3D_View)  gy = GadgetY(Canvas_3D_View)  gw = GadgetWidth(Canvas_3D_View)  gh = GadgetHeight(Canvas_3D_View)  ; Klick außerhalb der 3D-Ansicht ignorieren  If mx < gx Or mx >= gx + gw : ProcedureReturn : EndIf  If my < gy Or my >= gy + gh : ProcedureReturn : EndIf  ; In Screen-Koordinaten des OpenWindowedScreen umrechnen  sx = mx - gx  sy = my - gy  ; Raycast auf die Szene  hitEntity = MousePick(#Cam1, sx, sy)  If hitEntity = -1    ProcedureReturn  EndIf  ; Nur unser STL (oder optional Kanten-Entity) akzeptieren  If hitEntity <> #STLEntity And hitEntity <> #STLEdgeEntity    ProcedureReturn  EndIf  ; Grober Treffpunkt (auf der Bounding Box)  px = PickX()  py = PickY()  pz = PickZ()  ; Kamera-Position holen  camX = CameraX(#Cam1)  camY = CameraY(#Cam1)  camZ = CameraZ(#Cam1)  ; Ray-Richtung: von Kamera zum groben Treffer  dx = px - camX  dy = py - camY  dz = pz - camZ  ; Exakter Mesh-Treffer über Face()-Liste  If RayPickSTL(camX, camY, camZ, dx, dy, dz)    px = RayHit\x    py = RayHit\y    pz = RayHit\z  EndIf  ; --- Messpunkt in Liste eintragen ---  AddElement(MP())  MP()\ID   = NextMP_ID  MP()\PosX = px  MP()\PosY = py  MP()\PosZ = pz  ; Visualisierungs-Entity erstellen  e = CreateEntity(#PB_Any, MeshID(#MP_MarkerMesh), MaterialID(#MP_MarkerMat))  If e    MoveEntity(e, px, py, pz, #PB_Absolute)    ; Größe des Punktes anpassen (je nach Modellgröße)    ; hier ein fixer Faktor, kannst du bei Bedarf mit STLBox\maxX-minX etc. koppeln    ScaleEntity(e, PointScale, PointScale, PointScale, #PB_Absolute)    MP()\Entity = e  EndIf  NextMP_ID + 1    CADx = px  CADy = -pz  CADz = py    Debug "MP " + Str(MP()\ID) + "  X=" + StrF(CADx, 3) + "  Y=" + StrF(CADy, 3) + "  Z=" + StrF(CADz, 3)EndProcedureProcedure Button_Load_STL(Event)    Protected STL_File.s, Pattern.s    Pattern = "STereoLithography (*.stl)|*.stl|Alle Dateien (*.*)|*.*"  STL_File = OpenFileRequester("Bitte Datei zum Laden auswählen", "", Pattern, 0)    If STL_File        If STL_File_Laden(STL_File)      InitCameraOrbit()    Else      MessageRequester("Fehler!", "STL Laden fehlgeschlagen.")    EndIf        Debug "STL-Bounding-Box:--------------"    Debug "X-Min = " + StrF(STLBox\minX, 3)    Debug "X-Max = " + StrF(STLBox\maxX, 3)    Debug "Y-Min = " + StrF(STLBox\minZ, 3)    Debug "Y-Max = " + StrF(STLBox\maxZ, 3)    Debug "Z-Min = " + StrF(STLBox\minY, 3)    Debug "Z-Max = " + StrF(STLBox\maxY, 3)        Protected widthX.f = STLBox\maxX - STLBox\minX    Protected heightY.f = STLBox\maxY - STLBox\minY    Protected depthZ.f = STLBox\maxZ - STLBox\minZ        Debug "X: " + StrF(widthX, 3)    Debug "Y: " + StrF(depthZ, 3)    Debug "Z: " + StrF(heightY, 3)  EndIfEndProcedureProcedure Button_Load_IGS(Event)    Protected Pattern.s, IGS_File.s    Pattern = "IGS File (*.igs)|*.igs|Alle Dateien (*.*)|*.*"  IGS_File = OpenFileRequester("Bitte Datei zum Laden auswählen", "", Pattern, 0)  If IGS_File    If LoadIGES_Lines(IGS_File)      RotateIGESLinesXMinus90()      CreateIGESLineEntity()    EndIf  EndIf    ForEach IGESLines()    ;Debug "Line: (" + StrF(IGESLines()\x1,3) + "," + StrF(IGESLines()\y1,3) + "," + StrF(IGESLines()\z1,3) + ")  ->  (" + StrF(IGESLines()\x2,3) + "," + StrF(IGESLines()\y2,3) + "," + StrF(IGESLines()\z2,3) + ")"    ;Debug "Line: (" + StrF(IGESLines()\x1) + "," + StrF(IGESLines()\y1) + "," + StrF(IGESLines()\z1) + ")  ->  (" + StrF(IGESLines()\x2) + "," + StrF(IGESLines()\y2) + "," + StrF(IGESLines()\z2) + ")"  Next  EndProcedureStart_Programm();{ - Main LoopGlobal Quit.iGlobal Event.iGlobal LastLeftDown.iRepeat    Repeat    Event = WindowEvent()    If Event = #PB_Event_CloseWindow      Quit = #True    EndIf    If Event = #PB_Event_Timer      Select EventTimer()         Case #Timer1          ;Debug "Timer1"      EndSelect    EndIf    ;     If ExamineKeyboard() ;       If KeyboardPushed(#PB_Key_F1) : CurrentMP_Type = #MP_TYPE_Z      : EndIf;       If KeyboardPushed(#PB_Key_F2) : CurrentMP_Type = #MP_TYPE_XPLUS  : EndIf;       If KeyboardPushed(#PB_Key_F3) : CurrentMP_Type = #MP_TYPE_XMIN   : EndIf;       If KeyboardPushed(#PB_Key_F4) : CurrentMP_Type = #MP_TYPE_YPLUS  : EndIf;       If KeyboardPushed(#PB_Key_F5) : CurrentMP_Type = #MP_TYPE_YMIN   : EndIf;     EndIf      KHP_EL_Check_Main_Window_Events(Event)      Until Event = 0    If GetAsyncKeyState_(#VK_LBUTTON) & $8000    If LastLeftDown = 0      AddMeasurementPointFromMouse()      LastLeftDown = 1    EndIf  Else    LastLeftDown = 0  EndIf    UpdateCameraOrbitFromSpaceMouse()  RenderWorld()  FlipBuffers()  Until Quit;}End_Programm()DataSection  PrefDate:  Data.s "Name", "Value"  Data.s "LastPosX", "0"  Data.s "LastPosY", "0"  Data.s "End of Pref"EndDataSection; IDE Options = PureBasic 6.20 (Windows - x64); CursorPosition = 843; FirstLine = 159; Folding = 5AAQ-; EnableXP; EnableUnicode